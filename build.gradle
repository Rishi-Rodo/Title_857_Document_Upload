import com.typesafe.config.Config
import com.typesafe.config.ConfigFactory

buildscript {//properties that you need to build the project
    Properties constants = new Properties()
    file("$projectDir/./constants.properties").withInputStream { constants.load(it) }

    ext {
        corda_release_group = constants.getProperty("cordaReleaseGroup")
        corda_core_release_group =  constants.getProperty("cordaCoreReleaseGroup")
        corda_release_version = constants.getProperty("cordaVersion")
        corda_core_release_version = constants.getProperty("cordaCoreVersion")
        corda_gradle_plugins_version = constants.getProperty("gradlePluginsVersion")
        kotlin_version = constants.getProperty("kotlinVersion")
        junit_version = constants.getProperty("junitVersion")
        quasar_version = constants.getProperty("quasarVersion")
        log4j_version = constants.getProperty("log4jVersion")
        slf4j_version = constants.getProperty("slf4jVersion")
        corda_platform_version = constants.getProperty("platformVersion").toInteger()
        //springboot
        spring_boot_version = '2.0.2.RELEASE'
        spring_boot_gradle_plugin_version = '2.0.2.RELEASE'
    }

    repositories {
        mavenLocal()
        mavenCentral()
        maven { url 'https://software.r3.com/artifactory/corda-releases' }
    }

    dependencies {
        classpath "net.corda.plugins:cordapp:$corda_gradle_plugins_version"
        classpath "net.corda.plugins:cordformation:$corda_gradle_plugins_version"
        classpath "net.corda.plugins:quasar-utils:$corda_gradle_plugins_version"
        classpath "org.springframework.boot:spring-boot-gradle-plugin:$spring_boot_gradle_plugin_version"
    }
}

allprojects {//Properties that you need to compile your project (The application)
    apply from: "${rootProject.projectDir}/repositories.gradle"
    apply plugin: 'java'

    repositories {
        mavenLocal()
        mavenCentral()
        maven { url 'https://software.r3.com/artifactory/corda' }
        maven {
            url 'http://maven.petrikainulainen.net/repo'
        }
        maven { url 'https://jitpack.io' }
        maven { url 'https://repo1.maven.org/maven2/'}
    }

    tasks.withType(JavaCompile) {
        options.compilerArgs << "-parameters" // Required by Corda's serialisation framework.
    }

    jar {
        // This makes the JAR's SHA-256 hash repeatable.
        preserveFileTimestamps = false
        reproducibleFileOrder = true
        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        exclude '**/log4j2*.xml'
    }
}

apply plugin: 'net.corda.plugins.cordapp'
apply plugin: 'net.corda.plugins.cordformation'
apply plugin: 'net.corda.plugins.quasar-utils'

cordapp {
    info {
        name "Rodo_Title_MVP"
        vendor "Corda Open Source"
        targetPlatformVersion corda_platform_version
        minimumPlatformVersion corda_platform_version
    }
}


sourceSets {
    main {
        resources {
            srcDir rootProject.file("config/dev")
        }
    }
}
//Module dependencis
dependencies {
    // Corda dependencies.
    cordaCompile "$corda_core_release_group:corda-core:$corda_core_release_version"
    cordaCompile "$corda_release_group:corda-node-api:$corda_release_version"
    cordaRuntime "$corda_release_group:corda:$corda_release_version"
    compile "$corda_release_group:corda-jackson:$corda_release_version"


    // CorDapp dependencies.
    cordapp project(":workflows")
    cordapp project(":contracts")
    //compile project(":common")

    cordaCompile "org.apache.logging.log4j:log4j-slf4j-impl:${log4j_version}"
    cordaCompile "org.apache.logging.log4j:log4j-web:${log4j_version}"
    cordaCompile "org.slf4j:jul-to-slf4j:$slf4j_version"
    cordaDriver "net.corda:corda-shell:4.9"

}


//Task to deploy the nodes in order to bootstrap a network
task deployNodes(type: net.corda.plugins.Cordform, dependsOn: ['jar']) {

    /* This property will load the CorDapps to each of the node by default, including the Notary. You can find them
     * in the cordapps folder of the node at build/nodes/Notary/cordapps. However, the notary doesn't really understand
     * the notion of cordapps. In production, Notary does not need cordapps as well. This is just a short cut to load
     * the Corda network bootstrapper.
     */
    nodeDefaults {
        projectCordapp {
            deploy = false
        }
        cordapp project(':contracts')
        cordapp project(':workflows')
        //cordapp project(':common')

        runSchemaMigration = true //This configuration is for any CorDapps with custom schema, We will leave this as true to avoid
        //problems for developers who are not familiar with Corda. If you are not using custom schemas, you can change
        //it to false for quicker project compiling time.
    }

    node {
        name "O=Jay,L=New York,C=US"
        notary = [validating : false]
        p2pPort 10002
        rpcSettings {
            address("localhost:10003")
            adminAddress("localhost:10043")
        }
    }
    node {
        name "O=Hamilton,L=New York,C=US"
        p2pPort 10005
        rpcSettings {
            address("localhost:10006")
            adminAddress("localhost:10046")
        }

//        cordapps = [
//                "com.rodo:title-contract-state-schema:$version",
//        ]
        rpcUsers = [[ user: "user1", "password": "test", "permissions": ["ALL"]]]
    }

//    node {
//        name "O=Walcott,L=New York,C=US"
//        p2pPort 10008
//        rpcSettings {
//            address("localhost:10009")
//            adminAddress("localhost:10049")
//        }
//        rpcUsers = [[ user: "user1", "password": "test", "permissions": ["ALL"]]]
//    }

//    node {
//        name "O=Ford,L=Texas,C=US"
//        p2pPort 10011
//        rpcSettings {
//            address("localhost:10012")
//            adminAddress("localhost:10052")
//        }
//        rpcUsers = [[ user: "user1", "password": "test", "permissions": ["ALL"]]]
//    }

    node {
        name "O=Toyota,L=New York,C=US"
        p2pPort 10014
        rpcSettings {
            address("localhost:10015")
            adminAddress("localhost:10055")
        }

//        cordapps = [
//                "com.rodo:title-contract-state-schema:$version",
//        ]
        rpcUsers = [[ user: "user1", "password": "test", "permissions": ["ALL"]]]
    }

    node {
        name "O=Madison,L=New York,C=US"
        p2pPort 10017
        rpcSettings {
            address("localhost:10018")
            adminAddress("localhost:10058")
        }

//        cordapps = [
//                "com.rodo:title-contract-state-schema:$version",
//        ]

        rpcUsers = [[ user: "user1", "password": "test", "permissions": ["ALL"]]]
    }

//    node {
//        name "O=Monroe,L=Texas,C=US"
//        p2pPort 10020
//        rpcSettings {
//            address("localhost:10021")
//            adminAddress("localhost:10061")
//        }
//        rpcUsers = [[ user: "user1", "password": "test", "permissions": ["ALL"]]]
//    }


}

enum OS {
    MAC,
    WIN,
    LINUX
}

OS getOSName() {
    def osName = System.getProperty("os.name", "generic").toLowerCase(Locale.ENGLISH)
    if (osName.contains("mac") || osName.contains("darwin")) {
        return OS.MAC
    } else if (osName.contains("win")) {
        return OS.WIN
    } else return OS.LINUX
}

boolean isTmux() {
    System.getenv("TMUX") == null ? false : true
}
/* This task can made more clean and generic or customized as per requirement, though conveys the idea of reading the node.conf file and it's custom properties
Usage: gradle createServer -Penv=dev || gradle createServer -Penv=prod
*/

task createServer(dependsOn: [':rodo-madison-server:bootJar']) {
    doLast {
        int serverPort = 8081 // initial server port
        println 'Started create server task'
        def hasEnv = project.hasProperty('env')
        if (!hasEnv) {
            println "env: dev, selected. intialServer Port is now set to $serverPort"
        }
        if (hasEnv && !(env.toLowerCase() in ['dev', 'prod'])) {
            println "Invalid env: $env, only dev and prod supported!."
        } else {
            if (hasEnv && env.toLowerCase() == 'prod') {
                serverPort = 5050
                println "env: $env, selected. intialServer Port is now set to $serverPort ."
            }
            OS os = getOSName()
            println "Operating System $os"
            def rootBuildFolder = "./build/nodes/"
            def starterBatFile = new File(rootBuildFolder + "runserver.bat")
            def starterShFile = new File(rootBuildFolder + "runserver.sh")
            if (starterBatFile.exists() || starterShFile.exists()) {
                starterBatFile.delete()
                starterShFile.delete()
            }
            String regx = "[^A-Za-z0-9]"
            def winCMD = "start "
            def linux = "x-terminal-emulator -e "
            def linuxTmux = "tmux new-window -n "
            def macStart = "osascript -e 'tell app \"Terminal\" to do script \""
            def macEnd = "\"'"
            def newLine = System.getProperty("line.separator")
            new File(rootBuildFolder).listFiles().sort { it.name }.each { File dir ->
                if (dir.isDirectory() && !dir.getName().find(regx) && !(dir.getName().toLowerCase() in ["jay", "web-logs", "oracle","toyota","hamilton"])) {
                    Config config = ConfigFactory.parseFile(new File(dir.getPath() + "/node.conf"))
                    def rpcAddress = config.getString("rpcSettings.address")
//                    def rpcUsers = (HashMap) config.getAnyRefList("rpcUsers").get(0)
//                    def password = rpcUsers.get("password")
//                    def user = rpcUsers.get("user")
                    String javaCommand = " java -Dnodename=" + dir.getName() +
                            " -Dconfig.rpc.password=" + "test" +
                            " -Dconfig.rpc.address=" + rpcAddress +
                            " -Dmyprocessname=smcdev"+
                            " -Dconfig.rpc.username=" + "user1" +
                            " -Dserver.port=" + (serverPort++) +
                            " -jar " + getJarName(dir.getName())
                    if (os == OS.WIN) {
                        starterBatFile.append(winCMD + javaCommand + newLine)
                        return
                    }
                    if (os == OS.MAC) {
                        starterShFile.append(macStart + javaCommand + macEnd + newLine)
                        return
                    }
                    if (os == OS.LINUX)
                        if (isTmux()) {
                            starterShFile.append(linuxTmux + dir.getName()+"-server" + " '" + javaCommand + "'" + newLine)
                        } else {
                            starterShFile.append(linux + javaCommand + newLine)
                        }
                }
            }
            println 'Finished create server task'
        }
    }
}

private String getJarName(String name) {
    println(name);
    if(name.toLowerCase().contains('madison'))
        return project(':rodo-madison-server').jar.outputs.files.getSingleFile()
    else if(name.toLowerCase().contains('hamilton'))
        return project(':rodo-hamilton-server').jar.outputs.files.getSingleFile()
    else if(name.toLowerCase().contains('toyota'))
        return project(':rodo-toyota-server').jar.outputs.files.getSingleFile()
    else throw TaskExecutionException("Invalid name found")
}